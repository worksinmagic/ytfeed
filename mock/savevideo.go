// Code generated by MockGen. DO NOT EDIT.
// Source: plugin/savevideo/savevideo.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	ytfeed "github.com/worksinmagic/ytfeed"
	v3 "google.golang.org/api/youtube/v3"
	io "io"
	reflect "reflect"
	time "time"
)

// MockYoutubeVideoLister is a mock of YoutubeVideoLister interface
type MockYoutubeVideoLister struct {
	ctrl     *gomock.Controller
	recorder *MockYoutubeVideoListerMockRecorder
}

// MockYoutubeVideoListerMockRecorder is the mock recorder for MockYoutubeVideoLister
type MockYoutubeVideoListerMockRecorder struct {
	mock *MockYoutubeVideoLister
}

// NewMockYoutubeVideoLister creates a new mock instance
func NewMockYoutubeVideoLister(ctrl *gomock.Controller) *MockYoutubeVideoLister {
	mock := &MockYoutubeVideoLister{ctrl: ctrl}
	mock.recorder = &MockYoutubeVideoListerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockYoutubeVideoLister) EXPECT() *MockYoutubeVideoListerMockRecorder {
	return m.recorder
}

// List mocks base method
func (m *MockYoutubeVideoLister) List(part []string) *v3.VideosListCall {
	ret := m.ctrl.Call(m, "List", part)
	ret0, _ := ret[0].(*v3.VideosListCall)
	return ret0
}

// List indicates an expected call of List
func (mr *MockYoutubeVideoListerMockRecorder) List(part interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockYoutubeVideoLister)(nil).List), part)
}

// MockDataSaver is a mock of DataSaver interface
type MockDataSaver struct {
	ctrl     *gomock.Controller
	recorder *MockDataSaverMockRecorder
}

// MockDataSaverMockRecorder is the mock recorder for MockDataSaver
type MockDataSaverMockRecorder struct {
	mock *MockDataSaver
}

// NewMockDataSaver creates a new mock instance
func NewMockDataSaver(ctrl *gomock.Controller) *MockDataSaver {
	mock := &MockDataSaver{ctrl: ctrl}
	mock.recorder = &MockDataSaverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDataSaver) EXPECT() *MockDataSaverMockRecorder {
	return m.recorder
}

// SaveAs mocks base method
func (m *MockDataSaver) SaveAs(ctx context.Context, name string, r io.Reader) (int64, error) {
	ret := m.ctrl.Call(m, "SaveAs", ctx, name, r)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveAs indicates an expected call of SaveAs
func (mr *MockDataSaverMockRecorder) SaveAs(ctx, name, r interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveAs", reflect.TypeOf((*MockDataSaver)(nil).SaveAs), ctx, name, r)
}

// Delete mocks base method
func (m *MockDataSaver) Delete(ctx context.Context, name string) error {
	ret := m.ctrl.Call(m, "Delete", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete
func (mr *MockDataSaverMockRecorder) Delete(ctx, name interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockDataSaver)(nil).Delete), ctx, name)
}

// Exists mocks base method
func (m *MockDataSaver) Exists(ctx context.Context, name string) (bool, error) {
	ret := m.ctrl.Call(m, "Exists", ctx, name)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists
func (mr *MockDataSaverMockRecorder) Exists(ctx, name interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockDataSaver)(nil).Exists), ctx, name)
}

// MockFilenameTemplater is a mock of FilenameTemplater interface
type MockFilenameTemplater struct {
	ctrl     *gomock.Controller
	recorder *MockFilenameTemplaterMockRecorder
}

// MockFilenameTemplaterMockRecorder is the mock recorder for MockFilenameTemplater
type MockFilenameTemplaterMockRecorder struct {
	mock *MockFilenameTemplater
}

// NewMockFilenameTemplater creates a new mock instance
func NewMockFilenameTemplater(ctrl *gomock.Controller) *MockFilenameTemplater {
	mock := &MockFilenameTemplater{ctrl: ctrl}
	mock.recorder = &MockFilenameTemplaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockFilenameTemplater) EXPECT() *MockFilenameTemplaterMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockFilenameTemplater) Execute(w io.Writer, data interface{}) error {
	ret := m.ctrl.Call(m, "Execute", w, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockFilenameTemplaterMockRecorder) Execute(w, data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockFilenameTemplater)(nil).Execute), w, data)
}

// MockStreamScheduler is a mock of StreamScheduler interface
type MockStreamScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockStreamSchedulerMockRecorder
}

// MockStreamSchedulerMockRecorder is the mock recorder for MockStreamScheduler
type MockStreamSchedulerMockRecorder struct {
	mock *MockStreamScheduler
}

// NewMockStreamScheduler creates a new mock instance
func NewMockStreamScheduler(ctrl *gomock.Controller) *MockStreamScheduler {
	mock := &MockStreamScheduler{ctrl: ctrl}
	mock.recorder = &MockStreamSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStreamScheduler) EXPECT() *MockStreamSchedulerMockRecorder {
	return m.recorder
}

// RegisterSchedule mocks base method
func (m *MockStreamScheduler) RegisterSchedule(runAt time.Time, data *ytfeed.Data) error {
	ret := m.ctrl.Call(m, "RegisterSchedule", runAt, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterSchedule indicates an expected call of RegisterSchedule
func (mr *MockStreamSchedulerMockRecorder) RegisterSchedule(runAt, data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterSchedule", reflect.TypeOf((*MockStreamScheduler)(nil).RegisterSchedule), runAt, data)
}
